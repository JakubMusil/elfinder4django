from connector.elfinder.exceptions import ParameterError, ElFinderCommandErrorfrom connector.settings import ELFINDER_ROOT, ELFINDER_URL, ELFINDER_THUMBfrom connector.elfinder import BaseCommandimport osimport hashlibclass OpenCommand(BaseCommand):	''' open directory'''	def config(self):		#print '' # u'INSIDE //////////////// COMMAND INIT+=========================++++++++++++++++++++++++++++++++++++++++++++++++++++++'		#super(OpenCommand, self).__init__(**kwargs)		#self.target = None		#self.init = None		#self.tree = None		#self.can_execute = False		#self.result = {}		self.options = {}		#self.required = []		print '\n'*9		print 'INSIDE OPENCOMM CONFIG'		self.optional = ['init', 'tree', 'target']		#def validate_params(self):		#if 'target' in self.req.params and self.req.params.get('target', [''])[0]:		#	self.target = self.req.params.get('target', [''])[0]		#	self.can_execute = True		#if 'init' in self.req.params and self.req.params.get('init', [''])[0]:		#	self.init = True		#	self.can_execute = True		#self.can_execute = True				def execute(self):		print '' # u'BEFORE VALIDATED ######################################################################'		self.validate_params()		if not self.can_execute:			raise ElFinderCommandError, 'Cannot Execute Command'		print '' # u'PARAMETER VALIDARED V  JHHHH$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$'		if self.init:			self.execute_init()		else:			self.execute_open()		self.execute_options()		self.execute_upload_max_size()		self.execute_api_ver()		self.success = True		def execute_init(self):		#print '' # u'\n\n\n\n\n\n EXECCCCC ININININININIJHNINIJN'		path = self.find_path(self.target) or ELFINDER_ROOT 		self.result['cwd'] = self.cwd(path)		self.result['files'] = self.cdc(path)		self.result['files'].append(self.get_dir_info(path))		if path != os.path.abspath(ELFINDER_ROOT):			self.result['files'].extend(self.cdc(ELFINDER_ROOT))			self.result['files'].append(self.get_dir_info(ELFINDER_ROOT))		#print '' # u'RESSSSSSSSSSSSSSSSSSSSSSSSSUUUUUUUUUUUUUUUUUU&&&&&&&&& ' +repr(self.result)			def execute_open(self):		path = self.find_path(self.target) or ELFINDER_ROOT 		self.result['cwd'] = self.cwd(path)		self.result['files'] = self.cdc(path)		#self.result['cwd']['volumeid'] = self.hash(path)[0:2] + '_'		#print '' # u'RESSSSSSSSSSSSSSSSSSSSSSSSSUUUUUUUUUUUUUUUUUU&&&&&&&&& ' +repr(self.result)	def execute_options(self, **overwrite):		self.options.update({			'options':{				'path':os.path.relpath(ELFINDER_ROOT, ELFINDER_ROOT),				'url':ELFINDER_URL,				'tmbUrl':'%s%s' %(ELFINDER_URL, 'tmb/'),				'disabled':[],				'seperator':'\\',				'copyOverwrite':1,				'archivers':{					'create':[],					'extract':[],				}			},		})	def execute_api_ver(self, api="2.0"):		self.api = {'api':api}	def execute_upload_max_size(self, upload_max="2M"):		self.upload_max = {'uplMaxSize':upload_max}	def get_result(self):		return (self.result, self.options, self.api, self.upload_max)	class FileCommand(BaseCommand):	''' output file contents to the browser (download) '''	def __init__(self, **kwargs):		super(FileCommand, self).__init__(**kwargs)		self.result = {}		self.target = u''		self.errors = []		self.headers = {			'Content-Disposition':'attachment; filename=foo.xls',		}		self.result_type=''	def validate_params(self):		if 'target' in self.req.params and self.req.params.get('target', [''])[0]:			self.target = self.req.params.get('target', [''])[0]			self.can_execute = True	def execute(self):		self.validate_params()		if self.can_execute:			path = self.find_path(self.target, resolution=True)			f = open(path, 'rb')			self.result = f.read()			f.close()			filename = os.path.basename(path)			try:				hs = hashlib.md5()				hs.update(filename)				hs.hexdigest()			except:				filename = u'%s.%s'%(self.hash(filename)[0:7],filename.rsplit('.', 1)[-1])			self.headers = {'Content-Disposition':u'attachment; filename=%s'%filename}			self.result_type = self.get_mime(path)[0]			self.success = True				class ParentsCommand(BaseCommand):	''' add to return child directories (not a command but option? todo) '''	def __init__(self, **kwargs):		super(ParentsCommand, self).__init__(**kwargs)		self.result = {}		self.target = None	def validate_params(self):		if 'target' in self.req.params and self.req.params.get('target', [''])[0]:			self.target = self.req.params.get('target', [''])[0]			#self.target = self.target.split('_')[1]			self.can_execute = True		else:			self.can_execute = False	def execute(self):		self.validate_params()		if not self.can_execute:			raise ElFinderCommandError, 'Cannot Execute Command'		print '' # r'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ BEFOR FIND PATH TRAGGRT ::__::: %s ' %self.target		path = os.path.abspath(self.find_path(self.target))				print '' # ur'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ AFTER FIND PATH ::: %s'%self.hash(ELFINDER_ROOT)		self.result.update({			'tree':self.get_parents(path)		})		#self.result['tree']['volumeid'] = '5f_'		#self.result['tree'] = [self.result['tree']]		print '' # ur'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ AFTER APPEND RESULT %s '		self.success = True	def get_parents(self, cwd):		l = []		vparent = os.path.dirname(ELFINDER_ROOT)		path = os.path.abspath(cwd)		while path != os.path.abspath(vparent):			if path == os.path.abspath(ELFINDER_ROOT):				l.append(self.cwd(path, True))			else:				l.append(self.cwd(path))			path = os.path.dirname(path)		print '' # u'Before RETUNNNNNNNNN +++++++++++++++++ %s'%l		return l			class TreeCommand(BaseCommand):	''' add to return parent directories (not a command but option? todo) '''	def __init__(self, **kwargs):		super(TreeCommand, self).__init__(**kwargs)		self.result = {}		self.target = None	def validate_params(self):		if 'target' in self.req.params and self.req.params.get('target', [''])[0]:			self.target = self.req.params.get('target', [''])[0]			#self.target = self.target.split('_')[1]			self.can_execute = True		else:			self.can_execute = False	def execute(self):		self.validate_params()		if not self.can_execute:			raise ElFinderCommandError, 'Cannot Execute Command'		path = self.find_path(self.target)		print '' # ur'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ AFTER FIND PATH ::: %s'%path		self.result.update({			'tree':self.filtering(path)		})		self.result['tree'].append(self.cwd(path))		#self.result['tree']['volumeid'] = '5f_'		#self.result['tree'] = [self.result['tree']]		print '' # ur'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ AFTER APPEND RESULT %s '		self.success = True		class LsCommand(BaseCommand):	''' list files in directory (not a command but option? todo) '''	def __init__(self, **kwargs):		super(LsCommand, self).__init__(**kwargs)		self.result = {}		self.target = None	def validate_params(self):		if 'target' in self.req.params and self.req.params.get('target', [''])[0]:			self.target = self.req.params.get('target', [''])[0]			#self.target = self.target.split('_')[1]			self.can_execute = True		else:			self.can_execute = False	def execute(self):		self.validate_params()		if not self.can_execute:			raise ElFinderCommandError, 'Cannot Execute Command'		path = self.find_path(self.target)		self.result.update({			'list':os.listdir(path)		})		self.success = True	class TmbCommand(BaseCommand):	''' create thumbnails for selected files '''	pass	class SizeCommand(BaseCommand):	''' return size for selected files '''	def __init__(self, **kwargs):		super(SizeCommand, self).__init__(**kwargs)		self.result = 0		self.result_type = 'application/json'	def validate_params(self):		print '' # u'Validate Params :::: %s ======++++++======++++=====+++++=====+++++=====+++++======+'%self.req.params		if 'targets[]' in self.req.params and self.req.params.get('targets[]', [''])[0]:			self.targets = self.req.params.get('targets[]', [''])			#self.target = self.target.split('_')[1]			self.can_execute = True		else:			self.can_execute = False	def execute(self):		self.validate_params()		if not self.can_execute:			raise ElFinderCommandError, 'Cannot Execute Command'		self.result = 0		for target in self.targets:			path = self.find_path(target)			try:				path = unicode(path, 'utf8')			except:				print 'English Name Error !'			print '' # '\n' * 5			print '' # u'PATH OF TARGET ::: %s is %s'%(target, path)			if path:				self.result += self.get_size(path)		print '' # u'WE GOT SIZE OFFFFFFQQQQQQQQ :::::: %s'%self.result		self.result = {'size':self.result}		self.success = Trueclass DimCommand(BaseCommand):	''' return image dimensions '''	def __init__(self, **kwargs):		super(DimCommand, self).__init__(**kwargs)		self.result = {}		self.target = u''		self.errors = []	def validate_params(self):		if 'target' in self.req.params and self.req.params.get('target', [''])[0]:			self.target = self.req.params.get('target', [''])[0]			self.can_execute = True			if not self.imglib:				self.can_execute = False				self.errors = ['errCmdNoSupport']	def execute(self):		self.validate_params()		if self.can_execute:			path = self.find_path(self.target)			size = 'unknown'			try:				import Image				image = Image.open(path)				size = '%dx%d'%image.size				self.success = True				self.result['dim'] = size			except:				print 'DIM ERRROR'				self.success = False					class MkdirCommand(BaseCommand):	''' create directory '''	def __init__(self, **kwargs):		super(MkdirCommand, self).__init__(**kwargs)		self.name = u''		self.result = {}		self.errors = []		self.target = u''	def validate_params(self):		if 'target' in self.req.params and self.req.params.get('target', [''])[0]:			if 'name' in self.req.params and self.req.params.get('name', [''])[0]:				self.target = self.req.params.get('target', [''])[0]				self.name = u'%s'%self.req.params.get('name', [''])[0]				self.can_execute = True		else:			self.can_execute = False	def execute(self):		print '' # 'RENAME COMMAND ________________________________________++++++++++++++++++++++++++++++'		self.validate_params()		if not self.can_execute:			raise ElFinderCommandError, 'Cannot Execute Command'		target_folder = self.find_path(self.target)		self.result['added'] = []		if not self.check_name(self.name):			self.success = False			self.errors = ['errMkdir', '#%s'%self.target, 'errInvName']		if not self.file_exists(target_folder, self.name):			full_path = os.path.join(target_folder, self.name)			os.mkdir(full_path)			self.result['added'].append(self.get_dir_info(full_path))			self.success = True		else:			self.success = False			self.errors.extend(['errMkdir', self.name, 'errExists', self.name])	class MkfileCommand(BaseCommand):	''' create text file '''	def __init__(self, **kwargs):		super(MkfileCommand, self).__init__(**kwargs)		self.name = u''		self.result = {}		self.errors = []		self.target = u''	def validate_params(self):		if 'target' in self.req.params and self.req.params.get('target', [''])[0]:			if 'name' in self.req.params and self.req.params.get('name', [''])[0]:				self.target = self.req.params.get('target', [''])[0]				self.name = u'%s'%self.req.params.get('name', [''])[0]				self.can_execute = True		else:			self.can_execute = False	def execute(self):		print '' # 'RENAME COMMAND ________________________________________++++++++++++++++++++++++++++++'		self.validate_params()		if not self.can_execute:			raise ElFinderCommandError, 'Cannot Execute Command'		target_folder = self.find_path(self.target)		self.result['added'] = []		if not self.check_name(self.name):			self.success = False			self.errors = ['errMkfile', '#%s'%self.target, 'errInvName']		if not self.file_exists(target_folder, self.name):			full_path = os.path.join(target_folder, self.name)			f = open(full_path, 'w')			f.close()			self.result['added'].append(self.get_file_info(full_path))			self.success = True		else:			self.success = False			self.errors.extend(['errMkfile', self.name, 'errExists', self.name])								class RmCommand(BaseCommand):	''' delete file '''	def __init__(self, **kwargs):		super(RmCommand, self).__init__(**kwargs)		self.result = {}		self.targets = []		self.success = False		self.errors = []	def validate_params(self):		if 'targets[]' in self.req.params and self.req.params.get('targets[]', ['']):			self.targets = self.req.params.get('targets[]', [''])			self.can_execute = True		else:			self.can_execute = False			self.errors = ['errCmdParams', 'remove']	def execute(self):		self.validate_params()		if self.can_execute:			self.result['removed'] = []			for target in self.targets:				path = self.find_path(target)				try:					path = unicode(path, 'utf8')				except:					print 'English name '				if os.path.isfile(path):					os.remove(path)					self.result['removed'].append(target)					self.success = True				else:					if self.remove_dir(path):						self.result['removed'].append(target)						self.success = True					def remove_dir(self, path):		try:			os.rmdir(path)			return True		except:			if self.force_remove(path):				try:					os.rmdir(path)					return True				except:					self.errors = ['errRm', os.path.basename(path)]					return False			else:				self.errors = ['errRm', os.path.basename(path)]		return True	def force_remove(self, dir):		#remove the directory even is its not empty		for curdir, dirs, files in os.walk(dir):			for f in files:				#print 'FILE::%s'%files				os.remove(os.path.join(curdir, f))			for d in dirs:				d = os.path.join(curdir, d)				#print 'DIR::%s -- FILES::%s'%(d, files)				if not os.listdir(d):					os.rmdir(d)			#and finally remove the current folder			if not os.listdir(curdir):				os.rmdir(curdir)		#then remove our folder		#os.rmdir(dir)		return Trueclass RenameCommand(BaseCommand):	''' rename file '''	def __init__(self, **kwargs):		super(RenameCommand, self).__init__(**kwargs)		self.result = {}		self.name = u''		self.target = u''		self.success = False			def validate_params(self):				if 'target' in self.req.params and self.req.params.get('target', [''])[0]:			if 'name' in self.req.params and self.req.params.get('name', [''])[0]:				print 'rename command parameters :)'				self.target = self.req.params.get('target', [''])[0]				self.name = u'%s'%self.req.params.get('name', [''])[0]				self.can_execute = True				print repr(self.name)		else:			self.can_execute = False	def execute(self):		print '' # 'RENAME COMMAND ________________________________________++++++++++++++++++++++++++++++'		self.validate_params()		if not self.can_execute:			raise ElFinderCommandError, 'Cannot Execute Command'		target_path = self.find_path(self.target)		print '' # 'TTHE PATH OF RENAME IS  KJKJKJKJKJKJKJKJ %s'%target_path		self.result['added'] = []		print '' # '\n'*10		#print '' # u'TARGET NAMNE IS ::::: %s AND NEWS FILES NAME IS ::::: %s'%(target_path, self.name)		if not self.check_name(self.name):			self.success = False			self.errors = ['errRename', '#%s'%self.target, 'errInvName']				elif not self.file_exists(os.path.dirname(target_path), self.name):			print '' # 'FILE NOT EXISTSSTDTYSDTDTDMJ FFFFF'			try:				print '' # '\n'*5				print '' # 'NOW WLL EXECUTE AND TURN THIS PATH TO REAL UNICODE :) %s'%target_path				try:					target_path = unicode(target_path, 'utf8')				except:					print '' # 'Ithink That This is a F! SEROUIGDS ENG ISSUE'				print '' # '\n'*5				print '' # 'CO)NVERTTED TO UNICODE SUCCESSSSSSSS'				new_path = os.path.join(os.path.dirname(target_path), self.name)				os.rename(target_path, new_path)				self.success = True				print '' # '\n'*5				print '' # u'AFTER RENAMING ____________________----------------------________________________------------'				if os.path.isdir(new_path):					self.result['added'].append(self.get_dir_info(new_path))				else:					self.result['added'].append(self.get_file_info(new_path))				self.result['removed'] = [self.target]				self.success = True				print '' # '\n'*5				print '' # u'AFTER SATBJHJ AFTER SUCCESSSSS ____________________----------------------________________________------------'			except Exception, e:				print '' # '\n'*6				print '' # u'THERE ARE SERIURWSS ERRRR ::: %s'%e				#here Comes errors				self.success = False				self.errors = ['errRename', '#%s'%self.target, 'errUnknown']		else:			self.success = False			exists = os.path.abspath(os.path.join(os.path.dirname(target_path), self.name))			self.errors = ['errRename', '#%s'%self.target, 'errExists', self.name]	class DuplicateCommand(BaseCommand):	''' create copy of file '''	def __init__(self, **kwargs):		super(DuplicateCommand, self).__init__(**kwargs)		self.targets = []		self.result = {}		self.errors = []	def validate_params(self):		if 'targets[]' in self.req.params and self.req.params.get('targets[]', [''])[0]:			self.targets = self.req.params.get('targets[]', [''])			self.can_execute = True		else:			self.can_execute = False			self.errors = ['errCmdParams', 'Duplicate']	def execute(self):		self.validate_params()		if self.can_execute:			self.result['added'] = []			for target in self.targets:				path = self.find_path(target, resolution=True)				new_path = self.unique_name(path)				if self.safe_copy(path, new_path):					self.result['added'].append(self.get_info(new_path))					self.success = True				else:					self.errors = ['errCopy', u'#%s'%target]					self.success = False	def unique_name(self, path, add=' copy '):		print 'START UNIQUE NAME'		dir = os.path.dirname(path)		name = os.path.basename(path)		basic_name = name #for directories		ext = ''		if not os.path.isdir(path):			name_com = name.split('.')			l = len(name_com)			if l == 2:				basic_name, ext = tuple(name_com)			if l == 1:				basic_name = name_com[0]			if l > 2:				if name_com[-1] in ['bz', 'bz2', 'gz']:					if name_com[-2] in ['tar']:						basic_name, ext = (u'.'.join(name_com[0:-2]), '.'.join(name_com[-2:]))				else:					basic_name, ext = (u'.'.join(name_com[0:-1]), name_com[-1])		basic_name = basic_name.split(add, 1)[0]		available_names = [n for n in os.listdir(dir) if n.startswith(basic_name) and add in n]		print repr(available_names)		i = 1		if available_names:			available_names.sort()			last_name = available_names[-1]			last_name = last_name.split(add)			last_name = last_name[-1].strip()			if ext:				last_name = last_name.split(ext)[0].split('.')[0]			print last_name			try:				i = int(last_name)				i += 1				print 'NOW THE FILE NAMWE WILL BE %d'%i			except:				pass		new_name = u'%s%s%d.%s'%(basic_name, add, i, ext)		if os.path.isdir(path):			new_name = u'%s%s%d'%(basic_name, add, i)		new_path = os.path.join(dir, new_name)		return new_path				class PasteCommand(BaseCommand):	''' copy or move files '''	def __init__(self, **kwargs):		super(PasteCommand, self).__init__(**kwargs)		self.success = False		self.errors = []		self.targets = []		self.dst = u''		self.src = u''		self.cut = False		self.kwargs = kwargs #used by rename command	def validate_params(self):		if 'targets[]' in self.req.params and self.req.params.get('targets[]', [''])[0]:			if 'src' in self.req.params and self.req.params.get('src', [''])[0]:				if 'dst' in self.req.params and self.req.params.get('dst', [''])[0]:					self.targets = self.req.params.get('targets[]', [''])					self.dst = self.req.params.get('dst', [''])[0]					self.src = self.req.params.get('src', [''])[0]					self.can_execute = True					if self.req.params.get('cut', [''])[0] == '1':						self.cut = True				else:					self.can_execute = False			else:				self.can_execute = False		else:			self.can_execute = False	def execute(self):		self.validate_params()		if self.can_execute:			destnation = self.find_path(self.dst, resolution=True)			source = self.find_path(self.src, resolution=True)			self.result['added'] = []			self.result['removed'] = []			for target in self.targets:				path = self.find_path(target, resolution=True)				new_path = os.path.abspath(os.path.join(destnation, os.path.basename(path)))				if self.cut:					try:						os.rename(path, new_path)						if os.path.isdir(new_path):							self.result['added'].append(self.get_dir_info(new_path))						else:							self.result['added'].append(self.get_file_info(new_path))						self.result['removed'].append(target)						self.success = True						continue					except:						self.errors = ['errMove', u'#%s'%target]						self.success = False				else:					if self.safe_copy(path, new_path):						if os.path.isdir(new_path):							self.result['added'].append(self.get_dir_info(new_path))						else:							self.result['added'].append(self.get_file_info(new_path))						self.result['removed'].append(target)						self.success = True						continue					else:						self.errors = ['errMove', u'#%s'%target]						self.success = False	def safe_copy(self, src, dst):		import shutil		if os.path.isfile(src):			try:				shutil.copyfile(src, dst)				shutil.copymode(src, dst)				return True			except:				return False		elif os.path.isdir(src):			try:				os.mkdir(dst)			except:				return False			for f in os.listdir(src):				new_src = os.path.join(src, f)				new_dist = os.path.join(dst, f)				if not self.safe_copy(new_src, new_dist):					return False		return True									class UploadCommand(BaseCommand):	''' upload file '''	def __init__(self, **kwargs):		super(UploadCommand, self).__init__(**kwargs)		self.result = {}		self.errors = []		self.target = u''		self.files = []	def validate_params(self):		if self.req.params.get('target', [''])[0]:			if self.req.params.get('upload[]', [None])[0]:				self.files = self.req.params.get('upload[]', [None])				self.target = self.req.params.get('target', [''])[0]				self.can_execute = True			else:				self.can_execute = False				self.errors = ['errUpload', 'errUploadNoFiles']	def execute(self):		self.validate_params()		if self.can_execute:			uploaded_list = []			self.result['added'] = []			self.result['removed'] = []			path = self.find_path(self.target, resolution=True)			for f in self.files:				file_name = f.name				full_path = os.path.join(path, file_name)				if self.file_exists(path, file_name):					self.result['removed'].append(self.hash(full_path))				try:					import codecs					temp = codecs.open(full_path, 'wb', encoding='utf8')					for chunk in f.chunks():						temp.write(chunk)					temp.close()				except:					temp = open(full_path, 'wb')					for chunk in f.chunks():						temp.write(chunk)					temp.close()				uploaded_list.append(full_path)			for ufile in uploaded_list:				self.result['added'].append(self.get_info(ufile))			self.success = True					class GetCommand(BaseCommand):	''' return text file contents '''	def __init__(self, **kwargs):		super(GetCommand, self).__init__(**kwargs)		self.errors = []		self.result = {}		self.target = u''	def validate_params(self):		if 'target' in self.req.params and self.req.params.get('target',[''])[0]:			self.target = self.req.params.get('target',[''])[0]			self.can_execute = True		else:			self.can_execute = False			self.errors = ['errCmdParams', 'Get']	def execute(self):		self.validate_params()		if self.can_execute:			path = self.find_path(self.target, resolution=True)			if not os.path.isfile(path):				self.success = False				self.errors = ['errGet', u'#%s'%self.target]			else:				import codecs				f = codecs.open(path, encoding='utf8')				self.result['content'] = f.read()				f.close()				self.success = True	class PutCommand(BaseCommand):	''' save text file '''	def __init__(self, **kwargs):		super(PutCommand, self).__init__(**kwargs)		self.target = u''		self.content = u''		self.errors = []		self.result = {}	def validate_params(self):		if 'target' in self.req.params and self.req.params.get('target', [''])[0]:			if 'content' in self.req.params:				self.content = self.req.params.get('content', [''])[0]				self.target = self.req.params.get('target', [''])[0]				self.can_execute = True		else:			self.can_execute = False	def execute(self):		self.validate_params()		if self.can_execute:			path = self.find_path(self.target, resolution=True)			import codecs			f = codecs.open(path, 'wb+', encoding='utf8')			f.write(self.content)			f.close()			self.result['changed'] = [self.get_info(path)]			self.success = True	class ArchiveCommand(BaseCommand):	''' create archive '''	pass	class ExtractCommand(BaseCommand):	''' extract archive '''	pass	class SearchCommand(BaseCommand):	''' search for files '''	def __init__(self, **kwargs):		super(SearchCommand, self).__init__(**kwargs)		self.result = {}		self.errors = []		self.q = u''	def validate_params(self):		if self.req.params.get('q', [''])[0]:			self.q = self.req.params.get('q', [''])[0]			self.can_execute = True		else:			self.errors = ['errCmdParams', 'Search']			self.can_execute = False	def execute(self):		self.validate_params()		if self.can_execute:			self.result['files'] = []			for path in self.get_match_list(self.q):				self.result['files'].append(self.get_info(path))			self.success = True	def get_match_list(self, q):		l = []		parent_path = u'%s'%ELFINDER_ROOT		for dirpath, dirnames, filenames in os.walk(parent_path):			if os.path.abspath(dirpath) == ELFINDER_THUMB:				continue			fl = [os.path.abspath(os.path.join(dirpath, f)) for f in filenames if q.lower() in f.lower()]			dl = [os.path.abspath(os.path.join(dirpath, d)) for d in dirnames if q.lower() in d.lower()]			l.extend(fl)			l.extend(dl)		return l			class InfoCommand(BaseCommand):	''' return info for selected files '''	def __init__(self, **kwargs):		super(InfoCommand, self).__init__(**kwargs)		self.targets = []		self.errors = []		self.result = {}	def validate_params(self):		if self.req.params.get('targets[]', [''])[0]:			self.targets = self.req.params.get('targets[]', [''])			self.can_execute = True	def execute(self):		self.validate_params()		if self.can_execute:			self.result['files'] = []			for target in self.targets:				path = self.find_path(target, resolution=True)				self.result['files'].append(self.get_info(path))			self.success = Trueclass ResizeCommand(BaseCommand):	''' resize target image '''	def __init__(self, **kwargs):		super(ResizeCommand, self).__init__(**kwargs)		self.result = {}		self.errors = []		self.target = u''		self.x = 0		self.y = 0		self.mode = u'resize'		self.width = 0		self.height = 0	def validate_params(self):		if 'target' in self.req.params and self.req.params.get('target', [''])[0]:			if 'mode' in self.req.params and self.req.params.get('mode', [''])[0]:				if 'width' in self.req.params and self.req.params.get('width', [''])[0]:					if 'height' in self.req.params and self.req.params.get('height', [''])[0]:						self.target = self.req.params.get('target', [''])[0]						self.mode = self.req.params.get('mode', [''])[0]						if self.mode == 'crop':							self.x = self.req.params.get('x', [''])[0]							self.y = self.req.params.get('y', [''])[0]						self.can_execute = True						try:							self.width = self.req.params and self.req.params.get('width', [''])[0]							self.height = self.req.params and self.req.params.get('height', [''])[0]							self.width = int(self.width)							self.height = int(self.height)							if self.mode == 'crop':								self.x = int(self.x)								self.y = int(self.y)						except:							self.errors = ['errResize', u'#%s'%self.target, 'errCmdParams', 'Image Resize']							self.can_execute = False						if not self.imglib:							self.can_execute = False							self.errors = ['errResize', u'#%s'%self.target, 'errCmdNoSupport']	def execute(self):		self.validate_params()		if self.can_execute:			path = self.find_path(self.target, resolution=True)			import Image			image = Image.open(path)			if self.mode == 'resize':				image = image.resize((self.width, self.height), 1)			else:				image = image.crop((self.x, self.y, self.width, self.height))			image.save(path)			self.result['changed'] = [self.get_info(path)]			self.success = True	COMMANDS_MAP = {	'open' : OpenCommand,	'file' : FileCommand,	'tree' : TreeCommand,	'parents' : ParentsCommand,	'ls' : LsCommand,	'tmb' : TmbCommand, 	'size' : SizeCommand,	'dim' : DimCommand,	'mkdir' : MkdirCommand,	'mkfile' : MkfileCommand,	'rm' : RmCommand,	'rename' : RenameCommand,	'duplicate' : DuplicateCommand,	'paste' : PasteCommand,	'upload' : UploadCommand,	'get' : GetCommand,	'put' : PutCommand,	'archive' : ArchiveCommand,#TODO	'extract' : ExtractCommand,#TODO	'search' : SearchCommand,	'info' : InfoCommand,	'resize' : ResizeCommand,}